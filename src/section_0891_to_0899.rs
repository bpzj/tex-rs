//! @* \[40] Pre-hyphenation.
//! When the line-breaking routine is unable to find a feasible sequence of
//! breakpoints, it makes a second pass over the paragraph, attempting to
//! hyphenate the hyphenatable words. The goal of hyphenation is to insert
//! discretionary material into the paragraph so that there are more
//! potential places to break.
//!
//! The general rules for hyphenation are somewhat complex and technical,
//! because we want to be able to hyphenate words that are preceded or
//! followed by punctuation marks, and because we want the rules to work
//! for languages other than English. We also must contend with the fact
//! that hyphens might radically alter the ligature and kerning structure
//! of a word.
//!
//! A sequence of characters will be considered for hyphenation only if it
//! belongs to a ``potentially hyphenatable part'' of the current paragraph.
//! This is a sequence of nodes $p_0p_1\ldots p_m$ where $p_0$ is a glue node,
//! $p_1\ldots p_{m-1}$ are either character or ligature or whatsit or
//! implicit kern nodes, and $p_m$ is a glue or penalty or insertion or adjust
//! or mark or whatsit or explicit kern node.  (Therefore hyphenation is
//! disabled by boxes, math formulas, and discretionary nodes already inserted
//! by the user.) The ligature nodes among $p_1\ldots p_{m-1}$ are effectively
//! expanded into the original non-ligature characters; the kern nodes and
//! whatsits are ignored. Each character |c| is now classified as either a
//! nonletter (if |lc_code(c)=0|), a lowercase letter (if
//! |lc_code(c)=c|), or an uppercase letter (otherwise); an uppercase letter
//! is treated as if it were |lc_code(c)| for purposes of hyphenation. The
//! characters generated by $p_1\ldots p_{m-1}$ may begin with nonletters; let
//! $c_1$ be the first letter that is not in the middle of a ligature. Whatsit
//! nodes preceding $c_1$ are ignored; a whatsit found after $c_1$ will be the
//! terminating node $p_m$. All characters that do not have the same font as
//! $c_1$ will be treated as nonletters. The |hyphen_char| for that font
//! must be between 0 and 255, otherwise hyphenation will not be attempted.
//! \TeX\ looks ahead for as many consecutive letters $c_1\ldots c_n$ as
//! possible; however, |n| must be less than 64, so a character that would
//! otherwise be $c_{64}$ is effectively not a letter. Furthermore $c_n$ must
//! not be in the middle of a ligature.  In this way we obtain a string of
//! letters $c_1\ldots c_n$ that are generated by nodes $p_a\ldots p_b$, where
//! |1<=a<=b+1<=m|. If |n>=l_hyf+r_hyf|, this string qualifies for hyphenation;
//! however, |uc_hyph| must be positive, if $c_1$ is uppercase.
//!
//! The hyphenation process takes place in three stages. First, the candidate
//! sequence $c_1\ldots c_n$ is found; then potential positions for hyphens
//! are determined by referring to hyphenation tables; and finally, the nodes
//! $p_a\ldots p_b$ are replaced by a new sequence of nodes that includes the
//! discretionary breaks found.
//!
//! Fortunately, we do not have to do all this calculation very often, because
//! of the way it has been taken out of \TeX's inner loop. For example, when
//! the second edition of the author's 700-page book {\sl Seminumerical
//! Algorithms} was typeset by \TeX, only about 1.2 hyphenations needed to be
//! @^Knuth, Donald Ervin@>
//! tried per paragraph, since the line breaking algorithm needed to use two
//! passes on only about 5 per cent of the paragraphs.
//!
//! @<Initialize for hyphenating...@>=
//! begin @!init if trie_not_ready then init_trie;@+tini@;@/
//! cur_lang:=init_cur_lang; l_hyf:=init_l_hyf; r_hyf:=init_r_hyf;
//! end
//!
//! @ The letters $c_1\ldots c_n$ that are candidates for hyphenation are placed
//! into an array called |hc|; the number |n| is placed into |hn|; pointers to
//! nodes $p_{a-1}$ and~$p_b$ in the description above are placed into variables
//! |ha| and |hb|; and the font number is placed into |hf|.
//!
//! @<Glob...@>=
//! @!hc:array[0..65] of 0..256; {word to be hyphenated}
//! @!hn:small_number; {the number of positions occupied in |hc|}
//! @!ha,@!hb:pointer; {nodes |ha..hb| should be replaced by the hyphenated result}
//! @!hf:internal_font_number; {font number of the letters in |hc|}
//! @!hu:array[0..63] of 0..256; {like |hc|, before conversion to lowercase}
//! @!hyf_char:integer; {hyphen character of the relevant font}
//! @!cur_lang,@!init_cur_lang:ASCII_code; {current hyphenation table of interest}
//! @!l_hyf,@!r_hyf,@!init_l_hyf,@!init_r_hyf:integer; {limits on fragment sizes}
//! @!hyf_bchar:halfword; {boundary character after $c_n$}
//!
//! @ Hyphenation routines need a few more local variables.
//!
//! @<Local variables for line...@>=
//! @!j:small_number; {an index into |hc| or |hu|}
//! @!c:0..255; {character being considered for hyphenation}
//!
//! @ When the following code is activated, the |line_break| procedure is in its
//! second pass, and |cur_p| points to a glue node.
//!
//! @<Try to hyphenate...@>=
//! begin prev_s:=cur_p; s:=link(prev_s);
//! if s<>null then
//!   begin @<Skip to node |ha|, or |goto done1| if no hyphenation
//!     should be attempted@>;
//!   if l_hyf+r_hyf>63 then goto done1;
//!   @<Skip to node |hb|, putting letters into |hu| and |hc|@>;
//!   @<Check that the nodes following |hb| permit hyphenation and that at least
//!     |l_hyf+r_hyf| letters have been found, otherwise |goto done1|@>;
//!   hyphenate;
//!   end;
//! done1: end
//!
//! @ @<Declare subprocedures for |line_break|@>=
//! @t\4@>@<Declare the function called |reconstitute|@>
//! procedure hyphenate;
//! label common_ending,done,found,found1,found2,not_found,exit;
//! var @<Local variables for hyphenation@>@;
//! begin @<Find hyphen locations for the word in |hc|, or |return|@>;
//! @<If no hyphens were found, |return|@>;
//! @<Replace nodes |ha..hb| by a sequence of nodes that includes
//!   the discretionary hyphens@>;
//! exit:end;
//!
//! @ The first thing we need to do is find the node |ha| just before the
//! first letter.
//!
//! @<Skip to node |ha|, or |goto done1|...@>=
//! loop@+  begin if is_char_node(s) then
//!     begin c:=qo(character(s)); hf:=font(s);
//!     end
//!   else if type(s)=ligature_node then
//!     if lig_ptr(s)=null then goto continue
//!     else begin q:=lig_ptr(s); c:=qo(character(q)); hf:=font(q);
//!       end
//!   else if (type(s)=kern_node)and(subtype(s)=normal) then goto continue
//!   else if type(s)=whatsit_node then
//!     begin @<Advance \(p)past a whatsit node in the \(p)pre-hyphenation loop@>;
//!     goto continue;
//!     end
//!   else goto done1;
//!   if lc_code(c)<>0 then
//!     if (lc_code(c)=c)or(uc_hyph>0) then goto done2
//!     else goto done1;
//! continue: prev_s:=s; s:=link(prev_s);
//!   end;
//! done2: hyf_char:=hyphen_char[hf];
//! if hyf_char<0 then goto done1;
//! if hyf_char>255 then goto done1;
//! ha:=prev_s
//!
//! @ The word to be hyphenated is now moved to the |hu| and |hc| arrays.
//!
//! @<Skip to node |hb|, putting letters...@>=
//! hn:=0;
//! loop@+  begin if is_char_node(s) then
//!     begin if font(s)<>hf then goto done3;
//!     hyf_bchar:=character(s); c:=qo(hyf_bchar);
//!     if lc_code(c)=0 then goto done3;
//!     if hn=63 then goto done3;
//!     hb:=s; incr(hn); hu[hn]:=c; hc[hn]:=lc_code(c); hyf_bchar:=non_char;
//!     end
//!   else if type(s)=ligature_node then
//!     @<Move the characters of a ligature node to |hu| and |hc|;
//!       but |goto done3| if they are not all letters@>
//!   else if (type(s)=kern_node)and(subtype(s)=normal) then
//!     begin hb:=s;
//!     hyf_bchar:=font_bchar[hf];
//!     end
//!   else goto done3;
//!   s:=link(s);
//!   end;
//! done3:
//!
//! @ We let |j| be the index of the character being stored when a ligature node
//! is being expanded, since we do not want to advance |hn| until we are sure
//! that the entire ligature consists of letters. Note that it is possible
//! to get to |done3| with |hn=0| and |hb| not set to any value.
//!
//! @<Move the characters of a ligature node to |hu| and |hc|...@>=
//! begin if font(lig_char(s))<>hf then goto done3;
//! j:=hn; q:=lig_ptr(s);@+if q>null then hyf_bchar:=character(q);
//! while q>null do
//!   begin c:=qo(character(q));
//!   if lc_code(c)=0 then goto done3;
//!   if j=63 then goto done3;
//!   incr(j); hu[j]:=c; hc[j]:=lc_code(c);@/
//!   q:=link(q);
//!   end;
//! hb:=s; hn:=j;
//! if odd(subtype(s)) then hyf_bchar:=font_bchar[hf]@+else hyf_bchar:=non_char;
//! end
//!
//! @ @<Check that the nodes following |hb| permit hyphenation...@>=
//! if hn<l_hyf+r_hyf then goto done1; {|l_hyf| and |r_hyf| are |>=1|}
//! loop@+  begin if not(is_char_node(s)) then
//!     case type(s) of
//!     ligature_node: do_nothing;
//!     kern_node: if subtype(s)<>normal then goto done4;
//!     whatsit_node,glue_node,penalty_node,ins_node,adjust_node,mark_node:
//!       goto done4;
//!     othercases goto done1
//!     endcases;
//!   s:=link(s);
//!   end;
//! done4:
